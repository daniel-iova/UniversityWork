from CerereImprimare import CerereImprimare
from OutputHandler import OutputHandler
from Imprimanta import Imprimanta

class ServiciuImprimare():
    """Printing Service Class"""
    def __init__(self):
        self.impr = [Imprimanta(i) for i in range(4)] # list of 4 Imprimanta objects, with ids from 0 to 3
        self.output = OutputHandler() # an OutputHandler object that handles printing to file
    
    def SetPPMValue(self, nums):
        """Sets the ppm (pages per minute) value for the four printers of the current printing service."""
        # uses the nums list generated by a DataGenerator object in the main module
        for i in range(4):
            self.impr[i].ppm = nums[i]

    def PushCerere(self, cerere : CerereImprimare):
        """Optimally chooses a printer and pushes the given request to it\'s job queue.
        Returns a finishing time and the index of the chosen printer."""
        # The most optimal printer has the fewest mins needed to finish their requests when adding given request

        # We use sorted() to make a sorted copy of the original 4 printers (because if we don't the simulation breaks)
        # The printers are sorted based on the return value of their TotalMinsWithCerere methods
        # Thus the first printer of the auxiliary array will be the most optimal
        iAux = sorted(self.impr, key = lambda imp : imp.TotalMinsWithCerere(cerere))

        # We find the index of the optimal printer in the original array
        id = iAux[0].id
        for i in range(4):
            if self.impr[i].id == iAux[0].id:
                id = i
                break
        
        # We push the request to the optimal printer's job queue
        self.impr[id].coadaDoc.Push(cerere)

        # We add the execution time of the request to the number of mins left
        self.impr[id].coadaDoc.minRamase += (cerere.ExecTimeForImp(iAux[0].ppm))

        # We update the finish time of the request
        minRamase = self.impr[id].coadaDoc.minRamase
        self.impr[id].coadaDoc.jobQueue[-1].finishTime = minRamase

        # We use the output object to signal the start of execution of the current request
        self.output.PrintStatus(self.impr[id], "a inceput", cerere)

        # We compute the finalTime (which is the minute when we need to pop the request)
        finalTime = minRamase + cerere.timestamp
        
        # We return the final time and the optimal printer's id
        return finalTime, id

    def PopCerere(self, printerID):
        """Pops the first element of the given printer's job queue."""
        popped = self.impr[printerID].coadaDoc.Pop()
        # We use the output object to signal the end of execution of the popped request
        self.output.PrintStatus(self.impr[printerID], "a terminat", popped)
    
    def Execute(self, requestList, startingTimes, timeTracker):
        """Executes requests using the given request list and starting times list.\n
        Given timeTracker is used to count minutes."""
        # The brain of the simulation
        # The requests are executed sequentially

        # The service sorts the 4 printers in ascending order, because
        # when pushing a request we want to push to the most optimal printer with the smallest ppm value
        # so that we leave room for documents with larger number of pages for the printers with bigger ppm values 
        self.impr.sort(key = lambda imp : imp.ppm)

        startIter = 0 # startingTimes iterator
        finishTimes = [] # list of finish times
        printerIDs = [] # list of optimal printer ids
        compLst = [-1]*len(startingTimes) # comparison list filled with -1, so we know when to stop the loop
        while finishTimes != compLst:
            # We update the remainining minutes and finish times
            self.UpdateTimes()

            self.output.PrintTimeTracker(timeTracker)

            # We test if the timeTracker is one of the finish times
            if timeTracker in finishTimes:
                # One or more requests can finish at once, so we count the occurances and find them using index()
                counter = finishTimes.count(timeTracker)
                for i in range(counter):
                    finishIndex = finishTimes.index(timeTracker)
                    # We pop the top request of the optimal printer's job queue
                    self.PopCerere(printerIDs[finishIndex])
                    # We set the finishTime at the current index to -1, so that in the end we can end the loop
                    finishTimes[finishIndex] = -1
            
            # We test if we are in bounds and the timeTracker is a starting time
            if startIter < len(startingTimes) and timeTracker == startingTimes[startIter]:
                # One or more requests can start at once, so we count the occurances and find them using index()
                counter = startingTimes.count(timeTracker)
                for i in range(counter):
                    startIndex = startingTimes.index(timeTracker)
                    # We push the request onto an optimal printer and get the finish time and printer id
                    finishTime, printerID = self.PushCerere(requestList[startIndex])
                    # We append the returned values to their respective lists
                    finishTimes.append(finishTime)
                    printerIDs.append(printerID)
                    # startingTimes at index startIndex becomes -1, so that we avoid an infinite loop when calling index()
                    startingTimes[startIndex] = -1
                    # The start iterator gets incremented
                    startIter += 1
            
            # Increment the timeTracker so now it holds the next minute
            timeTracker += 1

            # Printing the status of the 4 printers using the output object
            self.output.PrintPrinterStatus(self)

    def UpdateTimes(self):
        """Decrements with 1 the time left for every working printer.\n
        Decrements with 1 the internal finish time of every request of every working printer. """
        for imp in self.impr:
            # We only continue if the printer is working
            if imp.coadaDoc.isWorking:
                imp.coadaDoc.minRamase -= 1
                for cerere in imp.coadaDoc.jobQueue:
                    cerere.finishTime -= 1